#### 1. GET 和 HTTP PUT的区别

```js
1. GET:
 -Get用于请求资源，浏览器会对Get请求缓存，请求报文中实体为空，参数放入url中发送，浏览器对url有长度限制(IE最长2083个字符)，影响Get数据发送

2. POST:
 -Post用于发送数据，请求实体body为向服务器发送的数据(创建数据，会改变数据的种类资源)，支持的参数类型更多

3. PUT：
 -Put用于更新数据，不会增加数据的种类
```

#### 2. 常见的Content-Type属性值

```js
1. application/x-www-form-urlencoded: 原生form表单
2. multipart/form-data: 表单上传文件时使用
3. application/json: 消息主体是序列化后的JSON字符串
4. text/xml: 提交XML格式的数据
```

#### 3. 常见的HTTP请求方法

```js
GET : 向服务器获取数据
POST : 对服务器资源进行修改
PUT : 上传文件，更新数据
DELETE : 删除服务器上的数据
HEAD : 获取报文首部，不返回报文主体
OPTIONS : 询问服务器支持的请求方法，用来跨域请求
CONNECT : 与代理服务器通信时建立隧道，使用隧道进行TCP通信
TRACE : 回显服务器收到的请求，主要用于测试或诊断

OPTIONS: 
    - 获取服务器支持的所有请求方法
    - 用来检查访问权限。如在进行CORS跨域资源共享时，对于复杂请求，用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限
```

#### 4. HTTP 1.0 和 HTTP 1.1 以及 HTTP2.0 HTTP 3.0 的区别

```js
1. HTTP 1.0:
    - 非持久连接
    - 缓存方面主要使用header中的If-Modified-Since Expires来作为缓存判断标准

2. HTTP 1.1:
    - 持久连接(多个HTTP请求复用同一个TCP连接)，
    - 缓存方面引入更多控制策略，Etag，If-Unmodified-Since，If-Match，If-None-Match
    - 新增host字段，用来指定服务器的域名
    - 新增了请求方法，PUT,HEAD,OPTIONS

3. HTTP 2.0:
    - 二进制协议: 头信息和数据体都是二进制，统称为帧(头信息帧，数据帧)，帧是实现多路复用的基础
    - 多路复用: 仍用TCP连接，在一个连接里，客户端和服务器都可以同时发送多个请求/回应，不用按照顺序一一发送
    - 数据流: 由于数据包不按顺序发送，需要对数据包做标记，指出属于哪个请求。HTTP/2将每个请求或回应的所有数据包，称为一个数据流，每个数据流都有一个独一无二的编号
                数据包发送时，都必须标记数据流ID，用来区分它属于哪个数据流。
    - 头信息压缩: 避免每次请求都携带重复的字段和内容，头信息使用gzip/compress 压缩后发送；客户端和服务器同时维护一张头信息表，
                所有字段都存入这个表，生成一个索引号，以后只发送索引号
    - 服务器推送: 允许服务器主动向客户端发送资源(静态资源)，减少一些延迟时间。该推送与Websocket以及SSE方式发送的即时数据是不同的

4. HHTP 3.0:
    - 流量控制，传输可靠性功能(QUIC): 在UDP的基础上增加了一层来保证数据传输可靠性，提供了数据包重传，拥塞控制等其他TCP特性
    - 集成TLS加密功能:  目前QUIC使用TLS1.3，减少了握手所花费的RTT数
    - 多路复用: 统一物理连接可有多个独立的逻辑数据流，实现数据流的单独传输，解决了TCP的队头堵塞问题
    - 快速握手: 基于UDP,可实现使用0~1个RTT来建立连接
```

#### 5. OSI七层模型

```js
1. 物理层：通过物理介质传输比特流
2. 数据链路层：将比特组合成字节，再将字节组合成帧，使用链路层地址访问介质，并进行差错检测
3. 网络层：通过IP寻址来建立两个节点的连接，规定了数据包的传输路线
4. 传输层(TCP,UDP)：为上层协议提供端到端(端口号即为端)的可靠和透明的数据传输服务，包括处理差错控制和流量控制等
5. 会话层：负责建立，管理，和终止表示层实体之间的通信会话
6. 表示层：提供各种用于应用层数据的编码和转换功能
7. 应用层：为计算机用户提供应用接口，也为用户直接提供各种网络服务(HTTP，HTTPS，FTP，POP3、SMTP)
```

#### 6. TCP/IP五层协议

```js
1. 物理层：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境
2. 数据链路层：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等)
3. 网络层：负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机
4. 传输层：负责为两台主机中的进程提供通信服务
    - 传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；
    - 用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报
5. 应用层：应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等
```

#### 7. 即时通讯相关

```js
1. 短轮询：
    浏览器每隔一段时间向服务器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应(严重浪费了服务器端和客户端的资源)

2. 长轮询：
    由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。(连接挂起也会导致资源的浪费)

3. SSE(基于HTTP协议，单向通信)：
    服务器向客户端声明，接下来要发送的是流信息，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子

4. WebSocket：
    HTML新协议，全双工，可以相互发送消息

- 性能的角度来看：
    WebSocket > 长连接（SEE） > 长轮询 > 短轮询
兼容性来看相反
```

#### 8. 负载均衡及实现

```js
1. 将请求分发到不同的服务器上，减轻单个服务器的压力

2. 实现：
    - 反向代理
    - DNS方式：统一域名对应对个IP地址，用户请求，DNS返回域名对应的服务器IP地址的集合，每个回答中，循环这些IP地址的顺序，用户选择靠前的地址发送请求(DNS存在缓存，一个服务器故障后，可能解析返回的仍是该IP地址，造成访问问题)
```

#### 9. 正向代理 反向代理

```js
1. 正向代理：
    - 隐藏真实客户端，代理服务器代替请求，服务端不知真实请求的客户端是谁

2. 反向代理：
    - 隐藏真实的服务端，客户端请求会被代理转发到真正的服务器上(一般用来实现负载均衡)
```

#### 10. CDN(内容分发网络)：提高网站的访问速度，减轻源服务器的压力

```js
1. 将服务器上存储的静态内容缓存在CDN节点上，访问静态内容时，无需访问服务器源站，就近访问CDN节点即可获取相同内容，从而达到加速的效果

2. 当用户请求时，先发给CDN服务器，由服务器定位拥有该资源最近的服务器上请求
```
